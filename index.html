<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="./themes/prism.css" rel="stylesheet" />
    <link href="./reset.css" rel="stylesheet" />
    <link href="./main.css" rel="stylesheet" />
    <title>Codewars</title>
  </head>

  <body>
    <div class="container">
      <div class="static">
        <div class="flex_sb header">
          <div class="flex_left">
            <div>
              <a href="./index.html" class="btn2">Codewars</a>
            </div>
            <div>
              <a href="./metods.html" class="btn">Metods</a>
            </div>
            <div>
              <a href="./helps.html" class="btn">Helps</a>
            </div>
          </div>
          <div class="flex_right">
            <a
              class="mycodewars"
              href="https://www.codewars.com/users/Hajima-VD"
            >
              <img
                src="https://www.codewars.com/users/Hajima-VD/badges/large"
                alt="img"
              />
            </a>
          </div>
        </div>
      </div>
      <div class="null"></div>

      <!-- =================================================================================== -->
      <!-- <div class="discription">

                 <pre class="margin_pre">
                     <code class="language-js">
          
                     </code>
                    </pre>
                    <code class="language-js">
          
                     </code>
                </div> -->
      <!-- =================================================================================== -->
      <!-- <div class="discription">

                 <pre class="margin_pre">
                     <code class="language-js">
          
                     </code>
                    </pre>
                    <code class="language-js">
          
                     </code>
                </div> -->
      <!-- =================================================================================== -->
      <div class="discription">
        You like building blocks. You especially like building blocks that are squares. And what you even like more, is to arrange them into a square of square building blocks!
        However, sometimes, you can't arrange them into a square. Instead, you end up with an ordinary rectangle! Those blasted things! If you just had a way to know, whether you're currently working in vain… Wait! That's it! You just have to check if your number of building blocks is a perfect square.
        <br> Task <br>
        Given an integral number, determine if it's a square number:
        In mathematics, a square number or perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself.
        The tests will always use some integral number, so don't worry about that in dynamic typed languages.
        <br>
        Examples
        <br>
        -1  =>  false
        <br>
        0  =>  true
        <br>
        3  =>  false
        <br>
        4  =>  true
        <br>
        25  =>  true
        <br>
        26  =>  false
                 <pre class="margin_pre">
                     <code class="language-js">
  var isSquare = function(n){
    return Number.isInteger(Math.sqrt(n)) ; 
   }
                     </code>
                    </pre>
                    <code class="language-js">
          
                     </code>
                </div>
      <!-- =================================================================================== -->
      <div class="discription">
Welcome. In this kata, you are asked to square every digit of a number and concatenate them.
For example, if we run 9119 through the function, 811181 will come out, because 92 is 81 and 12 is 1. (81-1-1-81)
Example #2: An input of 765 will/should return 493625 because 72 is 49, 62 is 36, and 52 is 25. (49-36-25)
<br>
Note: The function accepts an integer and returns an integer.
                 <pre class="margin_pre">
                     <code class="language-js">
  function squareDigits(num){
    return +num.toString().split('').map(x => {
       return x ** 2;
     }).join('');
   }
                     </code>
                    </pre>
                    <code class="language-js">
          
                     </code>
                </div>
      <!-- =================================================================================== -->
      <div class="discription">
You were camping with your friends far away from home, but when it's time to go back, you realize that your fuel is running out and the nearest pump is 50 miles away! You know that on average, your car runs on about 25 miles per gallon. There are 2 gallons left.
<br>
Considering these factors, write a function that tells you if it is possible to get to the pump or not.
<br>
Function should return true if it is possible and false if not.
                 <pre class="margin_pre">
                     <code class="language-js">
   const zeroFuel = (distanceToPump, mpg, fuelLeft) => {
     return mpg*fuelLeft>distanceToPump ? true : false ;
   };
   console.log(zeroFuel(50,3,2));
                     </code>
                    </pre>
                    <code class="language-js">
          
                     </code>
                </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Given an array of integers. Return an array, where the first element is
        the count of positives numbers and the second element is sum of negative
        numbers. 0 is neither positive nor negative. If the input is an empty
        array or is null, return an empty array.
        <br />
        Example <br />
        For input [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -11, -12, -13, -14, -15], you
        should return [10, -65].
        <pre class="margin_pre">
                     <code class="language-js">
function countPositivesSumNegatives(input) {
  if (!input || input.length === 0) {
    return [];
  }
  const result = input.reduce((accumulator, currentValue) => {
    if (currentValue > 0) {
      accumulator[0]++;
    } else if (currentValue < 0) {
      accumulator[1] += currentValue;
    }
    return accumulator;
  }, [0, 0]);
  return result;
}
Примеры вызова функции:
countPositivesSumNegatives([1, -2, 3, 0, -5]); // [2, -7]
countPositivesSumNegatives([1, 2, 3]); // [3, 0]
countPositivesSumNegatives([-1, -2, -3]); // [0, -6]
countPositivesSumNegatives([]); // []
countPositivesSumNegatives(null); // []
                     </code>
                    </pre>
        <code class="language-js">
          Для решения данной задачи мы можем использовать метод .reduce() для
          подсчета количества положительных чисел и суммы отрицательных чисел. В
          качестве аргумента метода .reduce() мы передаем функцию, которая будет
          совершать операции над элементами массива. В данном случае, начальным
          значением аккумулятора будет [0, 0] - массив, где первый элемент равен
          0 (начальное количество положительных чисел), а второй элемент равен 0
          (начальная сумма отрицательных чисел). Далее, для каждого элемента
          массива мы проводим проверку. Если элемент положительный, мы добавляем
          1 к количеству положительных чисел. Если элемент отрицательный, мы
          добавляем его значение к сумме отрицательных чисел. Если элемент равен
          0, мы ничего не делаем. После того, как мы прошлись по всем элементам
          массива, мы возвращаем аккумулятор, который содержит количество
          положительных чисел в первом элементе и сумму отрицательных чисел во
          втором элементе. Код решения на JavaScript:
        </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        <pre class="margin_pre">
                     <code class="language-js">
          function positiveSum(arr) {
   return arr.reduce((a,b)=> a + (b > 0 ? b : 0),0);
}
                     </code>
                    </pre>
        <code class="language-js">
          Эта функция принимает массив чисел в качестве аргумента и возвращает
          сумму всех положительных чисел в массиве. Метод `reduce` используется
          для итерации по элементам массива и суммирования значений. В данном
          случае второй аргумент функции `reduce` это начальное значение
          аккумулятора, в нашем случае это 0. Далее, используется тернарный
          оператор `(b > 0 ? b : 0)`, который проверяет, является ли текущий
          элемент массива положительным. Если это так, то значение добавляется к
          аккумулятору, если нет - то добавляется 0. В итоге, функция возвращает
          сумму всех положительных элементов массива.
        </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        You get an array of numbers, return the sum of all of the positives
        ones.
        <br />
        Example [1,-4,7,12] => 1 + 7 + 12 = 20
        <br />
        Note: if there is nothing to sum, the sum is default to 0.
        <pre class="margin_pre">
                     <code class="language-js">
    function positiveSum(arr) {
      let positiveArr = arr.filter(num => num > 0 );
      if (positiveArr!=''){
        return positiveArr.reduce((acc, cur) => acc + cur);
      }
      return 0;
    }
                     </code>
                    </pre>
        <code class="language-js">
          Эта функция называется positiveSum. Она принимает массив (arr) чисел в
          качестве аргумента. Сначала функция использует метод filter для
          создания нового массива, в котором остаются только положительные числа
          (num > 0). Затем функция проверяет, не является ли новый массив
          пустым. Если массив не пустой, то функция использует метод reduce для
          вычисления суммы всех чисел в массиве. Результат суммирования
          возвращается из функции. Если новый массив пустой, то функция
          возвращает 0.
        </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Given a non-empty array of integers, return the result of multiplying
        the values together in order.
        <br />
        Example: <br />
        [1, 2, 3, 4] => 1 * 2 * 3 * 4 = 24
        <pre class="margin_pre">
                     <code class="language-js">
     function grow(x){
       return x.reduce((acc, cur) => acc * cur);
       }
                     </code>
                    </pre>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Write a program that finds the summation of every number from 1 to num.
        The number will always be a positive integer greater than 0.
        <br />
        For example (Input -> Output): <br />
        2 -> 3 (1 + 2) <br />
        8 -> 36 (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8)
        <pre class="margin_pre">
                     <code class="language-js">
    var summation = function (num) {
      let myArray = [];
      for (let i = 1; i <= num; i++) {
        myArray.push(i);
      }
      return myArray.reduce((acc, cur) => acc + cur);
    };
    console.log(summation(6));
//=======================================================//

    const summation = n => n * (n + 1) / 2;
                     </code>
                    </pre>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        A pangram is a sentence that contains every single letter of the
        alphabet at least once. For example, the sentence "The quick brown fox
        jumps over the lazy dog" is a pangram, because it uses the letters A-Z
        at least once (case is irrelevant). Given a string, detect whether or
        not it is a pangram. Return True if it is, False if not. Ignore numbers
        and punctuation.
        <pre class="margin_pre">
                     <code class="language-js">
   function isPangram(str) {
  // Создаем Set, чтобы хранить уникальные буквы из строки
  const letters = new Set();
  // Итерируемся по каждому символу в строке
  for (let i = 0; i < str.length; i++) {
    const char = str[i].toLowerCase();
    // Если символ является буквой от a до z, добавляем его в Set
    if (/[a-z]/.test(char)) {
      letters.add(char);
    }
  }
  // Если в Set'е есть все 26 букв, значит строка является панграммой
  return letters.size === 26;
}
                      
                      
Функция `isPangram()` принимает один аргумент `str` - строку, 
в которой нужно проверить, является ли она панграммой. 
В начале функции мы создаем Set `letters`, в котором 
будем хранить уникальные буквы из строки.
Затем мы итерируемся по каждому символу в строке. 
Если символ является буквой от a до z (игнорируем регистр), 
то мы добавляем его в Set `letters`.
В конце функции мы проверяем, есть ли в Set'е все 26 букв. 
Если да, то возвращаем `true`. Если нет, то возвращаем `false`.
Например:

console.log(isPangram("The quick brown fox jumps over the lazy dog")); // true
console.log(isPangram("Pack my box with five dozen liquor jugs")); // true
console.log(isPangram("Hello, world!")); // false

//------------------------------------------------------------//

function isPangram(string){
  return (string.match(/([a-z])(?!.*\1)/ig) || []).length === 26;
}
                     </code>
                    </pre>
                    <code class="language-js">
                     Эта функция определяет, является ли заданная строка "панграммой", 
то есть содержит ли она все буквы алфавита 
от A до Z (без учета регистра). Функция использует регулярное 
выражение `([a-z])(?!.*\1)`, которое ищет повторяющиеся буквы 
в строке и исключает их из поиска. Затем функция проверяет 
количество найденных уникальных букв и сравнивает его со 
значением 26 (количество букв в английском алфавите).
Если функция находит все 26 букв в строке, то 
возвращает `true`, иначе `false`.
                    </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Write a function that removes the spaces from the string, then return
        the resultant string.
        <pre class="margin_pre">
                     <code class="language-js">
       function noSpace(x){
         return x.replace(/\s/g, '');
       }
                     </code>
                    </pre>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        You are given an array(list) strarr of strings and an integer k. Your
        task is to return the first longest string consisting of k consecutive
        strings taken in the array. In the same way: longest_consec(["zone",
        "abigail", "theta", "form", "libe", "zas", "theta", "abigail"], 2) -->
        "abigailtheta" n being the length of the string array, if n = 0 or k > n
        or k <= 0 return "" (return Nothing in Elm, "nothing" in Erlang). Note
        consecutive strings : follow one after another without an interruption
        <pre class="margin_pre">
                     <code class="language-js">
   Examples:
   strarr = ["tree", "foling", "trashy", "blue", "abcdef", "uvwxyz"], k = 2
   
   Concatenate the consecutive strings of strarr by 2, we get:
   
   treefoling   (length 10)  concatenation of strarr[0] and strarr[1]
   folingtrashy ("      12)  concatenation of strarr[1] and strarr[2]
   trashyblue   ("      10)  concatenation of strarr[2] and strarr[3]
   blueabcdef   ("      10)  concatenation of strarr[3] and strarr[4]
   abcdefuvwxyz ("      12)  concatenation of strarr[4] and strarr[5]
   
   Two strings are the longest: "folingtrashy" and "abcdefuvwxyz".
   The first that came is "folingtrashy" so 
   longest_consec(strarr, 2) should return "folingtrashy".

  function longestConsec(strarr, k) {
    if (k > strarr.length || k <= 0) {
        return "";
    }
    let longestStr = "";
    for (let i = 0; i < strarr.length - k + 1; i++) {
        const currentStr = strarr.slice(i, i + k).join("");
        
        if (currentStr.length > longestStr.length) {
            longestStr = currentStr;
        }
    }
    return longestStr;
    }
                     </code>
                    </pre>
                    <code class="language-js">
                     Эта функция принимает входные параметры `strarr` (массив строк)
  и `k` (целочисленное значение), и возвращает первую самую 
  длинную строку, состоящую из k последовательных строк из массива.
  Сначала мы проверяем, если k равен 0 или больше, чем длина
  массива строк `strarr`, то функция возвращает пустую строку. 
  Далее мы создаем переменную `longestStr`, которая будет
  хранить самую длинную строку. Затем мы используем цикл `for`,
  чтобы перебрать каждую последовательность строк длины `k`
  и сравниваем их длины с длиной самой длинной строки. Если 
  текущая последовательность строк длиннее, чем самая длинная, 
  то мы обновляем значение переменной `longestStr`. В конце функции,
  мы возвращаем значение самой длинной строки.
  Например, если 
  `strarr` равен `["hello", "world", "this", "is", "a", "test"]` 
  и `k` равно `3`, то функция вернет строку `"thisisatest"`. 
  Это происходит потому, что самая длинная строка состоит из 
  трех последовательных строк: `"this"`, `"is"`, и `"a"`.
                    </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Complete the solution so that the function will break up camel casing,
        using a space between words. Example "camelCasing" => "camel Casing"
        "identifier" => "identifier" "" => ""
        <pre class="margin_pre">
                     <code class="language-js">
      function breakCamelCase(str) {
        return str.replace(/[A-Z]/g, ' $&');
      }
      Этот код использует метод replace() для поиска всех заглавных букв в 
      строке str и вставки перед ними пробела с помощью регулярного 
      выражения /[A-Z]/g. Здесь g означает глобальный поиск, который 
      находит все соответствия, а не только первое. $& означает найденный
      символ, поэтому перед ним ставится пробел. Таким образом, каждый раз,
      когда функция обнаруживает заглавную букву, она вставляет перед ней
      пробел, что и разбивает Camel Case.

      function solution(string) {
        string = string.split('').map(function (el) {
          if (el === el.toUpperCase()) {
            el = ' ' + el
          }
          return el
        })
        return string.join('')
      }
                     </code>
                    </pre>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Write a function to split a string and convert it into an array of
        words. Examples (Input ==> Output): "Robin Singh" ==> ["Robin", "Singh"]
        "I love arrays they are my favorite" ==> ["I", "love", "arrays", "they",
        "are", "my", "favorite"]
        <pre class="margin_pre">
                     <code class="language-js">
   function stringToArray(string){
       return string.split(' ');
   }
   console.log(stringToArray('heloo my world !!!'))
                     </code>
                    </pre>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        In a factory a printer prints labels for boxes. For one kind of boxes
        the printer has to use colors which, for the sake of simplicity, are
        named with letters from a to m. The colors used by the printer are
        recorded in a control string. For example a "good" control string would
        be aaabbbbhaijjjm meaning that the printer used three times color a,
        four times color b, one time color h then one time color a... Sometimes
        there are problems: lack of colors, technical malfunction and a "bad"
        control string is produced e.g. aaaxbbbbyyhwawiwjjjwwm with letters not
        from a to m. You have to write a function printer_error which given a
        string will return the error rate of the printer as a string
        representing a rational whose numerator is the number of errors and the
        denominator the length of the control string. Don't reduce this fraction
        to a simpler expression. The string has a length greater or equal to one
        and contains only letters from ato z. Examples: s="aaabbbbhaijjjm"
        printer_error(s) => "0/14" s="aaaxbbbbyyhwawiwjjjwwm" printer_error(s)
        => "8/22"
        <pre class="margin_pre">
                     <code class="language-js">
   function printer_error(s) {
   const errorCount   s.split('').filter(char => char > 'm').length;
   const totalCount = s.length;
   return `${errorCount}/${totalCount}`;
    }
    console.log(printer_error("sjfjakfbjhasbfjhabsf"));
                     </code>
                    </pre>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Build a function that returns an array of integers from n to 1 where
        n>0. Example : n=5 --> [5,4,3,2,1]
        <pre class="margin_pre">
                     <code class="language-js">
     const reverseSeq = n => {
       // объявляем пустой массив
        let myArray = [];
                 
       // заполняем массив значениями от 0 до 4
      for (let i = 1; i <= n; i++) {
             myArray.push(i);
          }
          return myArray.reverse();
         };
      console.log(reverseSeq(4));
                     </code>
                 </pre>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Clock shows h hours, m minutes and s seconds after midnight. Your task
        is to write a function which returns the time since midnight in
        milliseconds.
        <pre class="margin_pre">
                     <code class="language-js">
     function past(h, m, s){
         return result= (s+(m*60)+(h*60*60))*1000;
        }
        console.log(past(1,33,5));
                        </code>
                    </pre>
      </div>
      <!-- =================================================================================== -->
    </div>
    <script src="./prism.js"></script>
    <script src="./js.js"></script>
  </body>
</html>
