<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="./themes/prism.css" rel="stylesheet" />
    <link href="./reset.css" rel="stylesheet" />
    <link href="./main.css" rel="stylesheet" />
    <title>Codewars</title>
  </head>

  <body>
    <div class="container">
      <div class="static">
        <div class="flex_sb header">
          <div class="flex_left">
            <div>
              <a href="./index.html" class="btn2">Codewars</a>
            </div>
            <div>
              <a href="./metods.html" class="btn">Metods</a>
            </div>
            <div>
              <a href="./helps.html" class="btn">Helps</a>
            </div>
          </div>
          <div class="flex_right">
            <a
              class="mycodewars"
              href="https://www.codewars.com/users/Hajima-VD"
            >
              <img
                src="https://www.codewars.com/users/Hajima-VD/badges/large"
                alt="img"
              />
            </a>
          </div>
        </div>
      </div>
      <div class="null"></div>

      <!-- =================================================================================== -->
      <!-- <div class="discription">

                 <pre class="margin_pre">
                     <code class="language-js">
          
                     </code>
                    </pre>
                    <code class="language-js">
          
                     </code>
                </div> -->
      <!-- =================================================================================== -->
      <!-- <div class="discription">

                 <pre class="margin_pre">
                     <code class="language-js">
          
                     </code>
                    </pre>
                    <code class="language-js">
          
                     </code>
                </div> -->
      <!-- =================================================================================== -->
      <!-- <div class="discription">

                 <pre class="margin_pre">
                     <code class="language-js">
          
                     </code>
                    </pre>
                    <code class="language-js">
          
                     </code>
                </div> -->
      <!-- =================================================================================== -->
      <!-- <div class="discription">

                 <pre class="margin_pre">
                     <code class="language-js">
          
                     </code>
                    </pre>
                    <code class="language-js">
          
                     </code>
                </div> -->
      <!-- =================================================================================== -->
      <div class="discription">
      <br>  You might know some pretty large perfect squares. But what about the NEXT one?
      <br>  Complete the findNextSquare method that finds the next integral perfect square after the one passed as a parameter. Recall that an integral perfect square is an integer n such that sqrt(n) is also an integer.
      <br>  If the parameter is itself not a perfect square then -1 should be returned. You may assume the parameter is non-negative.
      <br>  Examples:(Input --> Output)
      <br>  121 --> 144
      <br>  625 --> 676
      <br>  114 --> -1 since 114 is not a perfect square
                 <pre class="margin_pre">
                     <code class="language-js">
  function findNextSquare(sq) {
    const sqrt = sq ** 0.5;
   return Number.isInteger(sqrt) ? (sqrt+1)** 2 : -1 ;
 }
                     </code>
                    </pre>
                    <code class="language-js">
          
                     </code>
                </div>
      <!-- =================================================================================== -->
      <div class="discription">
      <br>  Given a string, you have to return a string in which each character (case-sensitive) is repeated once.
      <br>  Examples (Input -> Output):
      <br>  * "String"      -> "SSttrriinngg"
      <br>  * "Hello World" -> "HHeelllloo  WWoorrlldd"
      <br>  * "1234!_ "     -> "11223344!!__  "
                 <pre class="margin_pre">
                     <code class="language-js">
  function doubleChar(str) {
    let arr= str.split('');
      return arr.map(x => x+x).join('');
      } 
                     </code>
                    </pre>
                    <code class="language-js">
          
                     </code>
                </div>
      <!-- =================================================================================== -->
      <div class="discription">
        You live in the city of Cartesia where all roads are laid out in a
        perfect grid. You arrived ten minutes too early to an appointment, so
        you decided to take the opportunity to go for a short walk. The city
        provides its citizens with a Walk Generating App on their phones --
        everytime you press the button it sends you an array of one-letter
        strings representing directions to walk (eg. ['n', 's', 'w', 'e']). You
        always walk only a single block for each letter (direction) and you know
        it takes you one minute to traverse one city block, so create a function
        that will return true if the walk the app gives you will take you
        exactly ten minutes (you don't want to be early or late!) and will, of
        course, return you to your starting point. Return false otherwise. Note:
        you will always receive a valid array containing a random assortment of
        direction letters ('n', 's', 'e', or 'w' only). It will never give you
        an empty array (that's not a walk, that's standing still!).
        <br />
        <br />
        <code class="language-js">
          Решением этой задачи будет функция, которая принимает на вход массив
          направлений и возвращает true, если этот массив приведет нас к точке
          старта и займет 10 минут, и false в противном случае. Алгоритм решения
          такой: 1. Создать две переменные для подсчета количества шагов в
          каждом направлении - vertical и horizontal. 2. Пройтись по массиву
          направлений, и для каждой буквы увеличивать соответствующую переменную
          на 1 либо уменьшать ее на 1, в зависимости от направления. 3.
          Проверить, что общее количество шагов в каждом направлении равно 0
          (иначе мы не вернулись в точку старта). 4. Проверить, что общее
          количество шагов во всех направлениях равно 10 (иначе мы не затратили
          ровно 10 минут). 5. Если оба условия выполнены, вернуть true, иначе
          вернуть false. Здесь мы пройдемся по массиву walk, используя оператор
          switch для определения, в какую переменную нам нужно добавить 1 или
          вычесть 1 в зависимости от направления. Затем мы проверим, что обе
          переменные равны 0 и длина массива равна 10, и вернем true, если это
          так.
        </code>
        <pre class="margin_pre">
                     <code class="language-js">
                      
   function isValidWalk(walk) {
     let vertical = 0;
     let horizontal = 0;
     for (let direction of walk) {
       switch (direction) {
         case 'n': vertical++; break;
         case 's': vertical--; break;
         case 'e': horizontal++; break;
         case 'w': horizontal--; break;
        }
      }
      return vertical === 0 && horizontal === 0 && walk.length === 10;
    }
    
  //=================================================================// 
  
  мое решение логика другая , но все работает. 
  Хотя codewars тесты не проходит ...
    function isValidWalk(walk) {
      let resultw = walk;
      let resultn = walk;
      let results = walk;
      let resulte = walk;
      for (let i = 0; i < walk.length; i++) {
        resultw = resultw.filter((resultw) => resultw == "w");
      }
      for (let i = 0; i < walk.length; i++) {
        resultn = resultn.filter((resultn) => resultn == "n");
      }
      for (let i = 0; i < walk.length; i++) {
        results = results.filter((results) => results == "s");
      }
      for (let i = 0; i < walk.length; i++) {
        resulte = resulte.filter((resulte) => resulte == "e");
      }
      const w = +resultw.length;
      const e = +resulte.length;
      const n = +resultn.length;
      const s = +results.length;
      return (walk.length = 10 && n === s && w === e);
    }
    
    console.log(isValidWalk(["w", "w", "w", "w", "w", "e", "e", "e", "e", "e"]));
                     </code>
                    </pre>
        <code class="language-js"> </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        <br />
        Your goal in this kata is to implement a difference function, which
        subtracts one list from another and returns the result. <br />
        It should remove all values from list a, which are present in list b
        keeping their order. <br />
        arrayDiff([1,2],[1]) == [2] <br />
        If a value is present in b, all of its occurrences must be removed from
        the other: <br />
        arrayDiff([1,2,2,2,3],[2]) == [1,3]
        <pre class="margin_pre">
                     <code class="language-js">
    function arrayDiff(a, b) {
      let result = a;
     for (let i=0;i < b.length ;i++){
       let arg=b[i];
       result= result.filter(result => result!= arg);
     }
   
     return result;
   }
                     </code>
                    </pre>
        <code class="language-js">
          Данная функция принимает два массива a и b и возвращает новый массив,
          состоящий из элементов массива a, которые не содержатся в массиве b.
          Первый параметр в функции - это массив a, а второй параметр - массив
          b, из которого нужно исключить элементы. Далее создается переменная
          result, которая равна массиву a. Затем в цикле for перебираются
          элементы массива b, каждый из которых используется для фильтрации
          массива result. То есть, из массива result удаляются все элементы,
          которые совпадают с текущим элементом из массива b. После прохождения
          цикла возвращается измененный массив result. Таким образом, все
          элементы массива a, которые содержатся в массиве b, будут исключены из
          результирующего массива.
        </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        <br />
        You have to write a function that accepts three parameters: cap is the
        amount of people the bus can hold excluding the driver. on is the number
        of people on the bus excluding the driver. wait is the number of people
        waiting to get on to the bus excluding the driver. If there is enough
        space, return 0, and if there isn't, return the number of passengers he
        can't take. <br />
        Usage Examples: <br />
        cap = 10, on = 5, wait = 5 --> 0 # He can fit all 5 passengers <br />
        cap = 100, on = 60, wait = 50 --> 10 # He can't fit 10 of the 50 waiting
        <pre class="margin_pre">
                     <code class="language-js">
    function enough(cap, on, wait) {
      return (on + wait - cap)>0 ? on + wait - cap : 0
  }      
                     </code>
                    </pre>
        <code class="language-js"> </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        <pre class="margin_pre">
                     <code class="language-js">
  function expandedForm(num) { 
     // создаем функцию, принимающую в качестве аргумента число
    let numString = num.toString(); 
    // преобразуем число в строку
    let result = []; 
    // создаем пустой массив, куда будут добавляться элементы числа в виде строк
    for (let i = 0; i < numString.length; i++) { 
      // перебираем каждый символ числа
      let digit = numString[i]; 
      // получаем текущую цифру
      if (digit !== '0') { 
        // если цифра не равна нулю
        let zeros = numString.length - i - 1; 
        // вычисляем количество нулей, которые нужно добавить в конце числа
        let numStringWithZeros = digit + '0'.repeat(zeros);
         // создаем строку, в которую добавляем нули в конце
        result.push(numStringWithZeros); 
        // добавляем полученную строку в результат
      }
    }
    return result.join(' + '); 
    // объединяем элементы массива с помощью разделителя " + " и возвращаем результат
  }
                    </code>
                  </pre>
        <code class="language-js">
          Давайте рассмотрим код подробнее: 1. Сначала мы создаем функцию
          `expandedForm`, которая принимает число `num` в качестве аргумента. 2.
          Затем мы преобразуем это число в строку, чтобы мы могли легко
          перебирать каждый символ. let numString = num.toString(); 3. Мы
          создаем пустой массив `result`, в котором мы будем хранить каждую
          цифру числа в виде строки. let result = []; 4. Затем мы используем
          цикл `for`, чтобы перебрать каждую цифру в числе и добавить ее в
          массив `result`. for (let i = 0; i < numString.length; i++) { let
          digit = numString[i]; } 5. Внутри цикла, мы получаем текущую цифру
          числа с помощью `numString[i]`, затем проверяем, равна ли эта цифра
          нулю. 6. Если цифра не равна нулю, то мы вычисляем количество нулей,
          которые нужно добавить в конце числа, и создаем новую строку
          `numStringWithZeros`, в которую добавляем нули в конце числа. if
          (digit !== '0') { let zeros = numString.length - i - 1; let
          numStringWithZeros = digit + '0'.repeat(zeros); } 7. Затем мы
          добавляем полученную строку в массив `result`. if (digit !== '0') {
          result.push(numStringWithZeros); } 8. По окончании цикла, мы
          объединяем все элементы массива `result` в одну строку, добавляя " + "
          между каждым элементом. return result.join(' + '); 9. В конце функция
          возвращает полученный результат. function expandedForm(num) { return
          result.join(' + '); }
        </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        <br />
        You will be given a number and you will need to return it as a string in
        Expanded Form. For example: <br />
        expandedForm(12); // Should return '10 + 2' <br />
        expandedForm(42); // Should return '40 + 2' <br />
        expandedForm(70304); // Should return '70000 + 300 + 4' <br />
        NOTE: All numbers will be whole numbers greater than 0.
        <br />
        <br />
        <code class="language-js">
          Для решения этой задачи нужно раскладывать число на его разряды. Для
          этого с помощью метода split() мы разбиваем число на отдельные цифры,
          а затем находим единицы, десятки и сотни, и если число равно 0,
          пропускаем его. Затем мы объединяем полученные строки с помощью "+" и
          возвращаем итоговую строку.
        </code>
        <pre class="margin_pre">
                     <code class="language-js">
   function expandedForm(num) {
     let str = num.toString(); // преобразуем число в строку
     let result = ''; // инициализируем результат
     let zeros = ''; // ноль как заполнитель
   
     // Перебираем каждую цифру в строке слева направо
     for (let i = 0; i < str.length; i++) {
       let digit = str[i]; // текущая цифра
       let multiplier = Math.pow(10, str.length - 1 - i); // множитель для разряда
       let expanded = digit * multiplier; // результат для данной цифры и разряда
   
       // Если текущая цифра не равна 0, добавляем результат для данной цифры и разряда в итоговую строку
       if (digit !== '0') {
         result += zeros + expanded;
         zeros = ' + '; // заполняем ноль как разделитель между слагаемыми
       }
     }
   
     return result;
   }
   Пример использования:
   console.log(expandedForm(12)); // '10 + 2'
   console.log(expandedForm(42)); // '40 + 2'
   console.log(expandedForm(70304)); // '70000 + 300 + 4'
                     </code>
                    </pre>
        <code class="language-js"> </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        <br />
        Write a function to convert a name into initials. This kata strictly
        takes two words with one space in between them. <br />
        The output should be two capital letters with a dot separating them.
        <br />
        It should look like this: <br />
        Sam Harris => S.H <br />
        patrick feeney => P.F
        <br />
        <code class="language-js">
          Для решения задачи нужно создать функцию, которая принимает на вход
          строку, содержащую два слова, разделенных пробелом. Для этого можно
          использовать метод split(' '), который разделит строку на две
          подстроки, сохраняя их в массив. Затем нужно получить первую букву
          каждого слова в верхнем регистре и склеить их вместе, разделяя точкой.
          Вот функция, которая решает эту задачу:
        </code>
        <pre class="margin_pre">
                     <code class="language-js">
    function getInitials(name) {
        const words = name.split(' ');
        const firstLetters = words.map(word => word.charAt(0).toUpperCase());
        return firstLetters.join('.');
    }
                    </code>
                  </pre>
        <code class="language-js">
          Функция split() разделяет строку на две подстроки и сохраняет их в
          массив `words`. Затем мы вызываем метод map() для массива `words`,
          чтобы получить первую букву каждого слова в верхнем регистре,
          используя метод charAt() и toUpperCase(). Мы сохраняем эти буквы в
          массив `firstLetters`. В конце мы склеиваем элементы массива
          `firstLetters`, разделяя их точкой, с помощью метода join() и
          возвращаем результат. Таким образом, при вызове функции
          getInitials('Sam Harris') мы получим `S.H`, а при вызове
          `getInitials('patrick feeney')` - `P.F`.
        </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Первым шагом необходимо создать функцию, которая будет принимать два
        аргумента - список и число N. Затем мы будем создавать пустой объект, в
        который будем добавлять уникальные элементы из списка в качестве ключей,
        и количество их повторений в качестве значений. Далее мы будем
        проходиться по списку, проверять количество повторений каждого элемента
        в объекте и добавлять элемент в новый список только в том случае, если
        количество повторений не превышает N. Когда мы получили новый список, он
        будет содержать каждый элемент из исходного списка не более N раз, без
        изменения порядка элементов.
        <pre class="margin_pre">
                     <code class="language-js">
     function limitList(list, n) {
       let obj = {};
       let result = [];
       
       for(let i = 0; i < list.length; i++) {
         let num = list[i];
         obj[num] = obj[num] ? obj[num] + 1 : 1;
         
         if(obj[num] <= n) {
           result.push(num);
         }
       }
       
       return result;
     }
     
     console.log( limitList([1,2,3,1,2,1,2,3], 2) );
      // [1, 2, 3, 1, 2, 3]
     console.log( limitList([20,37,20,21], 1) );
      // [20, 37, 21]
                     </code>
                    </pre>
        <code class="language-js">
          В первых двух строках создаем функцию и определяем аргументы. Затем
          создаем пустой объект и пустой массив, который будем заполнять. Далее,
          при помощи цикла-for, мы проходимся по списку. Для каждого элемента
          увеличиваем значение его ключа в объекте obj. Если значение этого
          ключа меньше или равно числу N, то мы добавляем этот элемент в новый
          массив result. В конце мы возвращаем полученный массив result с
          ограничением на количество повторений каждого элемента в N.
        </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        <br />
        Write function bmi that calculates body mass index (bmi = weight /
        height2). <br />
        if bmi <= 18.5 return "Underweight" <br />
        if bmi <= 25.0 return "Normal" <br />
        if bmi <= 30.0 return "Overweight" <br />
        if bmi > 30 return "Obese"
        <pre class="margin_pre">
                     <code class="language-js">
    function bmi(weight, height) {
      const bmi = weight /(height*height)
      if  (bmi<= 18.5){
        return "Underweight";
      } else if(bmi<= 25.0){
        return  "Normal";
      } else if(bmi<=30.0){
        return "Overweight";
      }else (bmi>30 )
      return "Obese"
    }
                     </code>
                    </pre>
        <code class="language-js"> </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Make a program that filters a list of strings and returns a list with
        only your friends name in it. If a name has exactly 4 letters in it, you
        can be sure that it has to be a friend of yours! Otherwise, you can be
        sure he's not...
        <br />
        Ex: Input = ["Ryan", "Kieran", "Jason", "Yous"], Output = ["Ryan",
        "Yous"]
        <br />
        i.e.
        <br />
        friend ["Ryan", "Kieran", "Mark"] `shouldBe` ["Ryan", "Mark"] Note: keep
        the original order of the names in the output.
        <br />
        Для решения данной задачи на JavaScript можно использовать метод
        filter() для массивов.
        <br />
        Первым шагом можно проверить каждый элемент массива на наличие только
        буквенных символов, например, с помощью регулярного выражения [^a-zA-Z].
        Если такие символы есть в имени друга, то этот элемент должен быть
        исключен из итогового массива.
        <br />
        Затем, можно применить метод filter(), чтобы отфильтровать исходный
        массив с помощью условия на длину имени: если длина имени в точности
        равна 4, то элемент добавляется в итоговый массив.
        <br />
        Для проверки можно использовать следующий код:
        <pre class="margin_pre">
                     <code class="language-js">
                      
                    
  function filterFriends(names) {
    const validNames = names.filter(name => /^[a-zA-Z]+$/.test(name));
     // проверяем на наличие только буквенных символов
    const friends = validNames.filter(name => name.length === 4); 
    // отбираем только имена друзей длины 4
    return friends;
  }
  console.log(filterFriends(["Ryan", "Kieran", "Mark", "123", "Bob", "Yous"]));
   // ["Ryan", "Mark", "Yous"]
                     </code>
                    </pre>
        <code class="language-js">
          На первой строке мы используем метод filter() для массива names, чтобы
          удалить все имена, содержащие не только буквенные символы. На второй
          строке мы используем снова метод filter() для массива validNames,
          чтобы оставить только имена, длина которых равна 4. Наконец, мы
          возвращаем массив friends, содержащий только имена друзей длины 4. В
          результате вызова функции с массивом ["Ryan", "Kieran", "Mark", "123",
          "Bob", "Yous"] должен вернуться массив ["Ryan", "Mark", "Yous"].
        </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Take an array and remove every second element from the array. Always
        keep the first element and start removing with the next element.
        <br />
        Example: <br />
        ["Keep", "Remove", "Keep", "Remove", "Keep", ...] --> ["Keep", "Keep",
        "Keep", ...] <br />
        None of the arrays will be empty, so you don't have to worry about that!

        <pre class="margin_pre">
                     <code class="language-js">
          const removeEveryOther = arr => arr.filter((_, i) => !(i % 2));
                     </code>
                    </pre>
        <code class="language-js">
          Эта функция удаляет из массива каждый второй элемент и возвращает
          новый массив, содержащий только элементы с индексами, кратными двум
          (то есть первый, третий, пятый и т. д.). Чтобы это сделать, функция
          использует метод filter, который применяет функцию сравнения,
          переданную ему в качестве аргумента, к каждому элементу в массиве. В
          данном случае эта функция сравнения имеет два аргумента: первый -
          текущий элемент массива, а второй - его индекс. В теле функции
          сравнения используется оператор %, который возвращает остаток от
          деления индекса на два. Если остаток равен нулю, тогда индекс является
          четным, и элемент сохраняется в результате. Если же остаток не равен
          нулю, то элемент не сохраняется в результате. Таким образом, при
          вызове функции removeEveryOther с массивом [1, 2, 3, 4, 5, 6, 7, 8, 9,
          10] возвращаемый результат будет [1, 3, 5, 7, 9].
        </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Take an array and remove every second element from the array. Always
        keep the first element and start removing with the next element.
        <br />
        Example: <br />
        ["Keep", "Remove", "Keep", "Remove", "Keep", ...] --> ["Keep", "Keep",
        "Keep", ...] <br />
        None of the arrays will be empty, so you don't have to worry about that!
        <br />
        <br />
        Для решения данной задачи мы используем функцию
        `removeEverySecondElement`. Внутри функции применяется метод массива
        `filter`, который работает следующим образом:
        <br />
        1. Метод `filter()` вызывается для исходного массива. <br />
        2. Мы передаем в `filter` анонимную стрелочную функцию `(element, index)
        => index % 2 === 0`, которая принимает два аргумента: `element` и
        `index`. Функция будет вызвана для каждого элемента массива. <br />
        3. Если условие внутри стрелочной функции `index % 2 === 0` выполняется
        (то есть индекс элемента делится на 2 без остатка), то элемент остается
        в выводимом массиве, в противном случае - удаляется. <br />
        4. В результате мы получаем новый массив, в котором удалены все элементы
        с нечетными индексами (начиная со второго элемента).
        <pre class="margin_pre">
        <code class="language-js">
   function removeEverySecondElement(array) {
     return array.filter((element, index) => index % 2 === 0);
   }
   
   const inputArray = ["Keep", "Remove", "Keep", "Remove", "Keep"];
   const resultArray = removeEverySecondElement(inputArray);
   console.log(resultArray); // ["Keep", "Keep", "Keep"]
        </code>
      </pre>
        <code class="language-js">
          Шаги для работы с примером: 1. Создаем исходный массив `inputArray`.
          2. Вызываем функцию `removeEverySecondElement` с исходным массивом в
          качестве аргумента и получаем результат в переменную `resultArray`. 3.
          Выводим результат в консоль.
        </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        You like building blocks. You especially like building blocks that are
        squares. And what you even like more, is to arrange them into a square
        of square building blocks! However, sometimes, you can't arrange them
        into a square. Instead, you end up with an ordinary rectangle! Those
        blasted things! If you just had a way to know, whether you're currently
        working in vain… Wait! That's it! You just have to check if your number
        of building blocks is a perfect square.
        <br />
        Task <br />
        Given an integral number, determine if it's a square number: In
        mathematics, a square number or perfect square is an integer that is the
        square of an integer; in other words, it is the product of some integer
        with itself. The tests will always use some integral number, so don't
        worry about that in dynamic typed languages.
        <br />
        Examples
        <br />
        -1 => false
        <br />
        0 => true
        <br />
        3 => false
        <br />
        4 => true
        <br />
        25 => true
        <br />
        26 => false
        <pre class="margin_pre">
                     <code class="language-js">
  var isSquare = function(n){
    return Number.isInteger(Math.sqrt(n)) ; 
   }
                     </code>
                    </pre>
        <code class="language-js"> </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Welcome. In this kata, you are asked to square every digit of a number
        and concatenate them. For example, if we run 9119 through the function,
        811181 will come out, because 92 is 81 and 12 is 1. (81-1-1-81) Example
        #2: An input of 765 will/should return 493625 because 72 is 49, 62 is
        36, and 52 is 25. (49-36-25)
        <br />
        Note: The function accepts an integer and returns an integer.
        <pre class="margin_pre">
                     <code class="language-js">
  function squareDigits(num){
    return +num.toString().split('').map(x => {
       return x ** 2;
     }).join('');
   }
                     </code>
                    </pre>
        <code class="language-js"> </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        You were camping with your friends far away from home, but when it's
        time to go back, you realize that your fuel is running out and the
        nearest pump is 50 miles away! You know that on average, your car runs
        on about 25 miles per gallon. There are 2 gallons left.
        <br />
        Considering these factors, write a function that tells you if it is
        possible to get to the pump or not.
        <br />
        Function should return true if it is possible and false if not.
        <pre class="margin_pre">
                     <code class="language-js">
   const zeroFuel = (distanceToPump, mpg, fuelLeft) => {
     return mpg*fuelLeft>distanceToPump ? true : false ;
   };
   console.log(zeroFuel(50,3,2));
                     </code>
                    </pre>
        <code class="language-js"> </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Given an array of integers. Return an array, where the first element is
        the count of positives numbers and the second element is sum of negative
        numbers. 0 is neither positive nor negative. If the input is an empty
        array or is null, return an empty array.
        <br />
        Example <br />
        For input [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -11, -12, -13, -14, -15], you
        should return [10, -65].
        <pre class="margin_pre">
                     <code class="language-js">
function countPositivesSumNegatives(input) {
  if (!input || input.length === 0) {
    return [];
  }
  const result = input.reduce((accumulator, currentValue) => {
    if (currentValue > 0) {
      accumulator[0]++;
    } else if (currentValue < 0) {
      accumulator[1] += currentValue;
    }
    return accumulator;
  }, [0, 0]);
  return result;
}
Примеры вызова функции:
countPositivesSumNegatives([1, -2, 3, 0, -5]); // [2, -7]
countPositivesSumNegatives([1, 2, 3]); // [3, 0]
countPositivesSumNegatives([-1, -2, -3]); // [0, -6]
countPositivesSumNegatives([]); // []
countPositivesSumNegatives(null); // []
                     </code>
                    </pre>
        <code class="language-js">
          Для решения данной задачи мы можем использовать метод .reduce() для
          подсчета количества положительных чисел и суммы отрицательных чисел. В
          качестве аргумента метода .reduce() мы передаем функцию, которая будет
          совершать операции над элементами массива. В данном случае, начальным
          значением аккумулятора будет [0, 0] - массив, где первый элемент равен
          0 (начальное количество положительных чисел), а второй элемент равен 0
          (начальная сумма отрицательных чисел). Далее, для каждого элемента
          массива мы проводим проверку. Если элемент положительный, мы добавляем
          1 к количеству положительных чисел. Если элемент отрицательный, мы
          добавляем его значение к сумме отрицательных чисел. Если элемент равен
          0, мы ничего не делаем. После того, как мы прошлись по всем элементам
          массива, мы возвращаем аккумулятор, который содержит количество
          положительных чисел в первом элементе и сумму отрицательных чисел во
          втором элементе. Код решения на JavaScript:
        </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        <pre class="margin_pre">
                     <code class="language-js">
          function positiveSum(arr) {
   return arr.reduce((a,b)=> a + (b > 0 ? b : 0),0);
}
                     </code>
                    </pre>
        <code class="language-js">
          Эта функция принимает массив чисел в качестве аргумента и возвращает
          сумму всех положительных чисел в массиве. Метод `reduce` используется
          для итерации по элементам массива и суммирования значений. В данном
          случае второй аргумент функции `reduce` это начальное значение
          аккумулятора, в нашем случае это 0. Далее, используется тернарный
          оператор `(b > 0 ? b : 0)`, который проверяет, является ли текущий
          элемент массива положительным. Если это так, то значение добавляется к
          аккумулятору, если нет - то добавляется 0. В итоге, функция возвращает
          сумму всех положительных элементов массива.
        </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        You get an array of numbers, return the sum of all of the positives
        ones.
        <br />
        Example [1,-4,7,12] => 1 + 7 + 12 = 20
        <br />
        Note: if there is nothing to sum, the sum is default to 0.
        <pre class="margin_pre">
                     <code class="language-js">
    function positiveSum(arr) {
      let positiveArr = arr.filter(num => num > 0 );
      if (positiveArr!=''){
        return positiveArr.reduce((acc, cur) => acc + cur);
      }
      return 0;
    }
                     </code>
                    </pre>
        <code class="language-js">
          Эта функция называется positiveSum. Она принимает массив (arr) чисел в
          качестве аргумента. Сначала функция использует метод filter для
          создания нового массива, в котором остаются только положительные числа
          (num > 0). Затем функция проверяет, не является ли новый массив
          пустым. Если массив не пустой, то функция использует метод reduce для
          вычисления суммы всех чисел в массиве. Результат суммирования
          возвращается из функции. Если новый массив пустой, то функция
          возвращает 0.
        </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Given a non-empty array of integers, return the result of multiplying
        the values together in order.
        <br />
        Example: <br />
        [1, 2, 3, 4] => 1 * 2 * 3 * 4 = 24
        <pre class="margin_pre">
                     <code class="language-js">
     function grow(x){
       return x.reduce((acc, cur) => acc * cur);
       }
                     </code>
                    </pre>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Write a program that finds the summation of every number from 1 to num.
        The number will always be a positive integer greater than 0.
        <br />
        For example (Input -> Output): <br />
        2 -> 3 (1 + 2) <br />
        8 -> 36 (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8)
        <pre class="margin_pre">
                     <code class="language-js">
    var summation = function (num) {
      let myArray = [];
      for (let i = 1; i <= num; i++) {
        myArray.push(i);
      }
      return myArray.reduce((acc, cur) => acc + cur);
    };
    console.log(summation(6));
//=======================================================//

    const summation = n => n * (n + 1) / 2;
                     </code>
                    </pre>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        A pangram is a sentence that contains every single letter of the
        alphabet at least once. For example, the sentence "The quick brown fox
        jumps over the lazy dog" is a pangram, because it uses the letters A-Z
        at least once (case is irrelevant). Given a string, detect whether or
        not it is a pangram. Return True if it is, False if not. Ignore numbers
        and punctuation.
        <pre class="margin_pre">
                     <code class="language-js">
   function isPangram(str) {
  // Создаем Set, чтобы хранить уникальные буквы из строки
  const letters = new Set();
  // Итерируемся по каждому символу в строке
  for (let i = 0; i < str.length; i++) {
    const char = str[i].toLowerCase();
    // Если символ является буквой от a до z, добавляем его в Set
    if (/[a-z]/.test(char)) {
      letters.add(char);
    }
  }
  // Если в Set'е есть все 26 букв, значит строка является панграммой
  return letters.size === 26;
}
                      
                      
Функция `isPangram()` принимает один аргумент `str` - строку, 
в которой нужно проверить, является ли она панграммой. 
В начале функции мы создаем Set `letters`, в котором 
будем хранить уникальные буквы из строки.
Затем мы итерируемся по каждому символу в строке. 
Если символ является буквой от a до z (игнорируем регистр), 
то мы добавляем его в Set `letters`.
В конце функции мы проверяем, есть ли в Set'е все 26 букв. 
Если да, то возвращаем `true`. Если нет, то возвращаем `false`.
Например:

console.log(isPangram("The quick brown fox jumps over the lazy dog")); // true
console.log(isPangram("Pack my box with five dozen liquor jugs")); // true
console.log(isPangram("Hello, world!")); // false

//------------------------------------------------------------//

function isPangram(string){
  return (string.match(/([a-z])(?!.*\1)/ig) || []).length === 26;
}
                     </code>
                    </pre>
        <code class="language-js">
          Эта функция определяет, является ли заданная строка "панграммой", то
          есть содержит ли она все буквы алфавита от A до Z (без учета
          регистра). Функция использует регулярное выражение `([a-z])(?!.*\1)`,
          которое ищет повторяющиеся буквы в строке и исключает их из поиска.
          Затем функция проверяет количество найденных уникальных букв и
          сравнивает его со значением 26 (количество букв в английском
          алфавите). Если функция находит все 26 букв в строке, то возвращает
          `true`, иначе `false`.
        </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Write a function that removes the spaces from the string, then return
        the resultant string.
        <pre class="margin_pre">
                     <code class="language-js">
       function noSpace(x){
         return x.replace(/\s/g, '');
       }
                     </code>
                    </pre>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        You are given an array(list) strarr of strings and an integer k. Your
        task is to return the first longest string consisting of k consecutive
        strings taken in the array. In the same way: longest_consec(["zone",
        "abigail", "theta", "form", "libe", "zas", "theta", "abigail"], 2) -->
        "abigailtheta" n being the length of the string array, if n = 0 or k > n
        or k <= 0 return "" (return Nothing in Elm, "nothing" in Erlang). Note
        consecutive strings : follow one after another without an interruption
        <pre class="margin_pre">
                     <code class="language-js">
   Examples:
   strarr = ["tree", "foling", "trashy", "blue", "abcdef", "uvwxyz"], k = 2
   
   Concatenate the consecutive strings of strarr by 2, we get:
   
   treefoling   (length 10)  concatenation of strarr[0] and strarr[1]
   folingtrashy ("      12)  concatenation of strarr[1] and strarr[2]
   trashyblue   ("      10)  concatenation of strarr[2] and strarr[3]
   blueabcdef   ("      10)  concatenation of strarr[3] and strarr[4]
   abcdefuvwxyz ("      12)  concatenation of strarr[4] and strarr[5]
   
   Two strings are the longest: "folingtrashy" and "abcdefuvwxyz".
   The first that came is "folingtrashy" so 
   longest_consec(strarr, 2) should return "folingtrashy".

  function longestConsec(strarr, k) {
    if (k > strarr.length || k <= 0) {
        return "";
    }
    let longestStr = "";
    for (let i = 0; i < strarr.length - k + 1; i++) {
        const currentStr = strarr.slice(i, i + k).join("");
        
        if (currentStr.length > longestStr.length) {
            longestStr = currentStr;
        }
    }
    return longestStr;
    }
                     </code>
                    </pre>
        <code class="language-js">
          Эта функция принимает входные параметры `strarr` (массив строк) и `k`
          (целочисленное значение), и возвращает первую самую длинную строку,
          состоящую из k последовательных строк из массива. Сначала мы
          проверяем, если k равен 0 или больше, чем длина массива строк
          `strarr`, то функция возвращает пустую строку. Далее мы создаем
          переменную `longestStr`, которая будет хранить самую длинную строку.
          Затем мы используем цикл `for`, чтобы перебрать каждую
          последовательность строк длины `k` и сравниваем их длины с длиной
          самой длинной строки. Если текущая последовательность строк длиннее,
          чем самая длинная, то мы обновляем значение переменной `longestStr`. В
          конце функции, мы возвращаем значение самой длинной строки. Например,
          если `strarr` равен `["hello", "world", "this", "is", "a", "test"]` и
          `k` равно `3`, то функция вернет строку `"thisisatest"`. Это
          происходит потому, что самая длинная строка состоит из трех
          последовательных строк: `"this"`, `"is"`, и `"a"`.
        </code>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Complete the solution so that the function will break up camel casing,
        using a space between words. Example "camelCasing" => "camel Casing"
        "identifier" => "identifier" "" => ""
        <pre class="margin_pre">
                     <code class="language-js">
      function breakCamelCase(str) {
        return str.replace(/[A-Z]/g, ' $&');
      }
      Этот код использует метод replace() для поиска всех заглавных букв в 
      строке str и вставки перед ними пробела с помощью регулярного 
      выражения /[A-Z]/g. Здесь g означает глобальный поиск, который 
      находит все соответствия, а не только первое. $& означает найденный
      символ, поэтому перед ним ставится пробел. Таким образом, каждый раз,
      когда функция обнаруживает заглавную букву, она вставляет перед ней
      пробел, что и разбивает Camel Case.

      function solution(string) {
        string = string.split('').map(function (el) {
          if (el === el.toUpperCase()) {
            el = ' ' + el
          }
          return el
        })
        return string.join('')
      }
                     </code>
                    </pre>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Write a function to split a string and convert it into an array of
        words. Examples (Input ==> Output): "Robin Singh" ==> ["Robin", "Singh"]
        "I love arrays they are my favorite" ==> ["I", "love", "arrays", "they",
        "are", "my", "favorite"]
        <pre class="margin_pre">
                     <code class="language-js">
   function stringToArray(string){
       return string.split(' ');
   }
   console.log(stringToArray('heloo my world !!!'))
                     </code>
                    </pre>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        In a factory a printer prints labels for boxes. For one kind of boxes
        the printer has to use colors which, for the sake of simplicity, are
        named with letters from a to m. The colors used by the printer are
        recorded in a control string. For example a "good" control string would
        be aaabbbbhaijjjm meaning that the printer used three times color a,
        four times color b, one time color h then one time color a... Sometimes
        there are problems: lack of colors, technical malfunction and a "bad"
        control string is produced e.g. aaaxbbbbyyhwawiwjjjwwm with letters not
        from a to m. You have to write a function printer_error which given a
        string will return the error rate of the printer as a string
        representing a rational whose numerator is the number of errors and the
        denominator the length of the control string. Don't reduce this fraction
        to a simpler expression. The string has a length greater or equal to one
        and contains only letters from ato z. Examples: s="aaabbbbhaijjjm"
        printer_error(s) => "0/14" s="aaaxbbbbyyhwawiwjjjwwm" printer_error(s)
        => "8/22"
        <pre class="margin_pre">
                     <code class="language-js">
   function printer_error(s) {
   const errorCount   s.split('').filter(char => char > 'm').length;
   const totalCount = s.length;
   return `${errorCount}/${totalCount}`;
    }
    console.log(printer_error("sjfjakfbjhasbfjhabsf"));
                     </code>
                    </pre>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Build a function that returns an array of integers from n to 1 where
        n>0. Example : n=5 --> [5,4,3,2,1]
        <pre class="margin_pre">
                     <code class="language-js">
     const reverseSeq = n => {
       // объявляем пустой массив
        let myArray = [];
                 
       // заполняем массив значениями от 0 до 4
      for (let i = 1; i <= n; i++) {
             myArray.push(i);
          }
          return myArray.reverse();
         };
      console.log(reverseSeq(4));
                     </code>
                 </pre>
      </div>
      <!-- =================================================================================== -->
      <div class="discription">
        Clock shows h hours, m minutes and s seconds after midnight. Your task
        is to write a function which returns the time since midnight in
        milliseconds.
        <pre class="margin_pre">
                     <code class="language-js">
     function past(h, m, s){
         return result= (s+(m*60)+(h*60*60))*1000;
        }
        console.log(past(1,33,5));
                        </code>
                    </pre>
      </div>
      <!-- =================================================================================== -->
    </div>
    <script src="./prism.js"></script>
    <script src="./js.js"></script>
  </body>
</html>
